# Kotlin

## Variables [note](../topics/kotlin/variables.md)

- What does it mean that a val instance is not automatically inmutable?
- Properties:
    - what is a property? backind fields and backing properties?
    - Extension properties:
        - What is the purpose?
        - Do they have state? why?
- lateinit
- delegated properties
- reflection

## Types [note](../topics/kotlin/types.md)

- What is Any?
- Are there primitives in kotlin? How kotlin treats primitive types compared with java?
- whenever you use a nullable kotlin type the JVM would use the wrapper instead 
of the primitive.
- What is Unit? Difference with void in java?
- Nothing type. Use cases?
- Explicit conversion:
    - toString conversion.

### Numbers

- How does kotlin works with over and underflow of numbers?

### Chars

- Char is not treated as a number.

### String

- Thriple quote:
    - Avoid escaping characters.
    - To use with Formatted text like json.

### Arrays

- Regular collection not treated as special (unlike Java).
- Specialized arrays. TODO

### Casting 

- Safe casting to non-Null type
- What is smart casting? How does it compare to java?
- Casting of chars.
- Explicit casting? When will it throw ClassCastException? How to work with nullability?

## Operators

- The "is" operator.
- Safe call.
- Elvis operator.
- Not-Null assertion: 
  avoid using multiple in a single line since the stack trace won't tell you wich 
  one is the problem
- The spread operator.
- operator overloading:
- destructuring declarations
- star projection

## Exceptions

- All are unchecked. What does it mean?

## Functions [note](../topics/kotlin/function.md)

- vararg:
  - what is the use?
- Extension functions:
    - Definition
    - What is the receiver type and object?
    - What languages does it support?
    - Can you access private variables?
    - What is the scope of an extension function?
    - Why they can't be override?
    - What if a member function and a extension function has the same function signature?
    - nullable types
- Infix functions
- local functions
- lambdas:
    - when can you move the curly braces from the parentheses?
    - When can you remove the parentheses?
    - type inference: when does and when it doesn't work?
    - member reference: a member reference has the same type as a lambda that 
      calls that function.
    - SAM interfaces.
    - lambdas with receivers:
        - with
        - apply
        - also

## Loops

- loops operators (ex: in, downTo, etc)
- The Comparable interface.
- loop statement (break, continue, return)
- repeat function
- labels

## Objects [note](../topics/kotlin/objects.md) 

The overriding member of a open base class or interface member means that is open for 
override. If you don't want this behaviour you have to mark as "final override...".

- Modifiers that control inheritance.

### Classes

- All classes are final by default and also their member functions.
- Visibility modifiers:
    - Exposing a class with a visibility modifier higher that of it's superclass 
      or extension function.
    - internal becomes public in the bytecode
- Inner classes:
    - The nested class don't hold a reference to the instance of the outer class
- Sealed class:
    - it's abstract without having to specify
    - when expressions and default branch
- Constructors:
    - Initializers:
        - what is the order of the multiple init and what is the purpose?
    - Secondary constructors:
        - Extend secondary constructors when subclassing
        - You can also call a secondary constructor of the same class
- Generated methods:
    - toString: mainly for debugging purposes
    - equals: object comparison
    - hashCode: the hashCode contract: If two objects are equal then their hashcode 
      are equal. It's required to work with data structures like a hashset.
- Data classes:
  - autogenerated methods by default
  - the properties not declared in the primary constructor does not take part 
    in the calculation of the equals and hashcode
  - recommended to use only val to make the instance of object complete inmutable
  - the copy method. What it does and for what?
- Class delegation with by
- object:
  - difference with a regular class
  - objects inside a class
  - companion objects
  - object expressions
- Inline classes

### Interfaces

- Sealed interfaces.
- Getters.

## Collections

- filter and map
- reduce and fold
- predicates
- count
- partition
- groupBy
- collections into map
- associateBy and associateWith
- mutable collections:
    - replaceAll and fill
    - ifEmpty and ifBlank
    - windowed and chunked function
- zip: Creates a list of pairs (or you can instantiate the object to want) with 
  two list. The list end up been the size of the smallest one.
- flatmap: flatten a list of collections into a single list.
- toSet: remove all duplicates
- sequences: asSequence and createSequence
- Collection and MutableCollections interface.
- Collections are not inmutable.
- arrays of primitives, conversion.

## Best practices

- The use of sealed classes with when expressions
- When to use read-only properties with no backind fields and when to use methods.

## Modules

## Java interoperability

### Functions 

- Default values in kotlin functions:
    - How to call a kotlin function that have default values from java code?
    - How can you make use of kotlin default values?
- Kotlin functions declared outside of a class:
    - How do they work?
    - Can you change the name of the generated class?
- Extension functions:
    - What is an extension function under the hood?
    - How to call an extension function from java?

### Collection

- All kotlin collections are copies of the java ones (one read-only and one modifiable)
- calling a kotlin collection from java


### Lambdas

- SAM and SAM constructors.
- In case you need to refer to the instance using this, then you better use an 
  annonimous objects.

### Nullability

- Kotlin is aware of java annotations. But if it isn't any then you would have 
  check for nullability or read the documentation.
  kotlin threats all java types as platform types. Meaning that they can non-null 
  or nullable. The nullability is unknown.

### Interfaces

- How to use a kotlin interface that has default implementations of functions?

### Classes

- Visibility modifiers:
    - no private classes in java
    - no internal in java
- data classes and records 
- objects:
    - INSTANCE
